---
// src/pages/writing/[...slug].astro
import { getCollection } from 'astro:content';
import PageLayout from '../../layouts/PageLayout.astro';
import fs from 'fs';
import path from 'path';

// This function runs at build time to find all publications
// and tell Astro to create a page for each one.
export async function getStaticPaths() {
  const writingEntries = await getCollection('writing');
  return writingEntries.map(entry => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

import CopyForChat from '../../components/CopyForChat.svelte';
import CiteButton from '../../components/CiteButton.svelte';
import EditSourceButton from '../../components/EditSourceButton.svelte';
import CitationDisplay from '../../components/CitationDisplay.svelte';
import TableOfContents from '../../components/TableOfContents.svelte';
import FootnoteManager from '../../components/FootnoteManager.svelte';
import FontSettings from '../../components/FontSettings.svelte';
import { parseBibtex, generatePlainText, generateZoteroMetadata } from '../../lib/citation-utils';
import { renderFulltextFromMarkdown } from '../../lib/fulltext-from-md.mjs';
import { generateJsonLd } from '../../lib/jsonld-utils';

const { entry } = Astro.props;
const { Content } = await entry.render(); // This gets the Markdown content

// Step 2 & 3: Check for markdown file and read content
const markdownFilePath = path.join(process.cwd(), 'public', 'md', `${entry.slug}.md`);
let hasMarkdownFile = fs.existsSync(markdownFilePath);
let markdownContent = '';

if (hasMarkdownFile) {
  try {
    markdownContent = fs.readFileSync(markdownFilePath, 'utf-8');
  } catch (error) {
    console.error(`Error reading markdown file for ${entry.slug}:`, error);
    hasMarkdownFile = false; // Treat as if file doesn't exist
  }
}

const bibtexData = entry.data.bibtex;
const contentHasFulltext = entry.body && entry.body.includes('<div class="fulltext"');
let injectedFulltextHtml = '';
if (!contentHasFulltext && hasMarkdownFile) {
  try {
    injectedFulltextHtml = await renderFulltextFromMarkdown(markdownContent);
  } catch (e) {
    injectedFulltextHtml = '';
    console.error('Error generating fulltext HTML from markdown for', entry.slug, e);
  }
}

// Generate Zotero metadata for citation detection
const zoteroMetadata = generateZoteroMetadata(entry);

// Generate JSON-LD structured data
const jsonLd = generateJsonLd(entry.data, 'writing', entry.slug);

// Step 4: Generate formatted citation
let formattedCitation = '';
if (hasMarkdownFile && bibtexData) {
  const parsed = parseBibtex(bibtexData);
  formattedCitation = generatePlainText(parsed).replace(/\*/g, ''); // Remove markdown formatting
}

// Format the content specifically for the clipboard
// Use the raw markdown body instead of the rendered Content component
const textForLLM = `
Title: ${entry.data.title}
Authors: ${entry.data.authors}
Year: ${entry.data.year}

---

${entry.body}
`.trim();


const instructionsForLLM = `Your task is to answer questions **about the \`<article>\` below**.

## Ground Rules

* **Primary source only:** Answer from the \`<article>\` unless the user explicitly asks for “related work.”
* **Faithful evidence:** Support key claims with **exact quotes** 
* When helpful you may follow a quote with a 1–2 sentence paraphrase for clarity. 
* **Scope control:** If the question **goes beyond the article**, say so clearly, answer what *is* covered, then offer an optional “Related Work” follow-up (off by default).
* **No speculation:** If the article is silent or ambiguous, say “not specified in this article.”
* **Terminology care:** Define technical terms the **first time** they matter, using exactly the definition given in the \`<article>\`. If the \`<article>\` is unclear about a term, say so.

## Answer Structure (use this order)

1. **Quick Answer (1–2 sentences).**
2. **Where in the Article.** Name section(s)/anchors and give 1–3 **short quotes** with brief paraphrases.
3. **Explanation.** Connect the quotes to the user’s question; resolve surface tensions; keep reasoning transparent.
4. **Key Terms (optional).** Short glosses for any crucial terms used in your answer.
5. **Limits.** Say what the article does **not** address or where it’s tentative.
6. **(Optional) Related Work.** *Only if the user opts in or asks.* Clearly label and **separate** from the article; attribute sources precisely.

## Evidence & Citation Policy

* For each main claim, include at least one **exact quote** and, if possible, a **section/anchor** (e.g., \`§The Reductive Strategy\`).
* When using **Related Work**, provide **source name + direct link** and keep it distinct from article-based evidence.

## Audience Awareness

* **If the question uses novice signals** (e.g., “what does X mean?” “explain like I’m new”), add a 1–3 sentence plain-language explanation.
* **If the question uses expert signals** (e.g., asks about List–Pettit vs Bratman, plural vs aggregate metaphysics), include 1–2 cross-references to the article’s relevant sections and (if user opted into Related Work) one or two canonical citations.

## When Users Ask for Related Work

* Use **“Related Work (outside this article)”** as a separate block.
* Prioritize a **neutral summary** + a **precise citation**. Do **not** mix these with the article’s claims.

`.trim()

// Step 5: Create enhanced content format for markdown files
let enhancedTextForLLM = '';
if (hasMarkdownFile) {
  enhancedTextForLLM = `<instructions>
${instructionsForLLM}
</instructions>

<article>
Title: ${entry.data.title}
Authors: ${entry.data.authors}
Year: ${entry.data.year}

<citation>
${formattedCitation}
</citation>

<full-text>
${markdownContent}
</full-text>
</article>`;
}


const pdfUrl = entry.data.pdfUrl;

// Define actions specific to this page
const pageActions = [];

// Add PDF download as first item if available
if (pdfUrl) {
  pageActions.push({
    label: 'Download PDF',
    action: 'openUrl',
    url: pdfUrl
  });
}

// Step 7: Add Copy for Chat only if markdown file exists
if (hasMarkdownFile) {
  pageActions.push({
    label: 'Copy for Chat',
    action: 'copyToClipboard',
    text: enhancedTextForLLM
  });
}


// Add open source action in development mode
if (import.meta.env.DEV) {
  pageActions.push({
    label: 'Edit Source',
    action: 'openSource',
    slug: entry.slug,
    contentType: 'writing'
  });
}

// Add citation actions if bibtex is available
if (bibtexData) {
  pageActions.push(
    {
      label: 'Copy BibTeX Citation',
      action: 'copyCitation',
      format: 'bibtex',
      bibtex: bibtexData
    },
    {
      label: 'Copy RIS Citation',
      action: 'copyCitation',
      format: 'ris',
      bibtex: bibtexData
    },
    {
      label: 'Copy Plain Text Citation',
      action: 'copyCitation',
      format: 'plaintext',
      bibtex: bibtexData
    },
    {
      label: 'Download BibTeX Citation',
      action: 'downloadCitation',
      format: 'bibtex',
      bibtex: bibtexData
    },
    {
      label: 'Download RIS Citation',
      action: 'downloadCitation',
      format: 'ris',
      bibtex: bibtexData
    },
    {
      label: 'Download Plain Text Citation',
      action: 'downloadCitation',
      format: 'plaintext',
      bibtex: bibtexData
    }
  );
}

---
<PageLayout title={entry.data.title} contextualActions={pageActions} zoteroMetadata={zoteroMetadata} jsonLd={jsonLd}>
    <CitationDisplay 
    bibtex={bibtexData}
    authors={entry.data.authors}
    year={entry.data.year}
    journal={entry.data.journal}
    doi={entry.data.doi}
    client:load 
  />
  <div class="flex justify-end mb-4 space-x-2">
    {hasMarkdownFile && (
      <CopyForChat contentToCopy={enhancedTextForLLM} client:load />
    )}
    {import.meta.env.DEV && (
      <span> </span> 
      <EditSourceButton slug={entry.slug} contentType="writing" client:load />
    )}
    {bibtexData && (
      <span> </span> 
      <CiteButton bibtex={bibtexData} client:load />
    )}
    {pdfUrl && (
      <a 
        href={pdfUrl} 
        target="_blank" 
        rel="noopener noreferrer"
        class="inline-flex items-center justify-center w-auto h-8 rounded-full bg-slate-100 hover:bg-blue-100 dark:bg-slate-700 dark:hover:bg-blue-900/50 transition-colors px-3"
      >
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-600 hover:text-blue-600 dark:text-slate-400 dark:hover:text-blue-400 mr-1" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
        </svg>
        <span class="text-xs font-medium text-slate-600 hover:text-blue-600 dark:text-slate-400 dark:hover:text-blue-400">
          PDF
        </span>
      </a>
    )}
  </div>

  
  <!-- Main content with footnote manager -->
  <div style="position: relative;" class="markdown-body-container footnote-manager-container">
    <Content /> <!-- This renders the main body of the Markdown file -->
    {(!contentHasFulltext && hasMarkdownFile && injectedFulltextHtml) && (
      <div set:html={injectedFulltextHtml} />
    )}
    <FootnoteManager client:load />
  </div>
  
  <!-- Font Settings Modal -->
  <FontSettings client:load />
  
  <!-- Table of Contents Modal -->
  <TableOfContents client:load />
</PageLayout>
